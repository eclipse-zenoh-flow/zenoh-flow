// use dpn_macros::zfoperator;
use zenoh_flow::InputRuleResult;
use zenoh_flow::{
    message::ZFCtrlMessage,
    serde::{Deserialize, Serialize},
    ZFContext,
};

// #[zfoperator(
//     modes = {"default": {"ir" : 'FizzOperator::ir_1, "run": FizzOperator::run_1, "or" :FizzOperator::or_1}},
//     inputs = [u128, String], // Can also pass a shared memory as input/output in that case we do not serialize/deserialize
//     output = [String, u128],
// )]
#[derive(Serialize, Deserialize)] //because of stateful, we need to serialize it inside the Runtime Context
struct FizzOperator {}

impl FizzOperator {
    fn run_1(
        &mut self,
        _ctx: &mut ZFContext,
        data: (Option<u128>,),
    ) -> (Option<String>, Option<u128>) {
        if let Some(val) = data.0 {
            if val % 2 == 0 {
                return (Some("Fizz".to_string()), Some(val));
            }

            return (None, Some(val));
        }

        unreachable!("This should never happen.");
    }

    fn ir_1(&self, _ctx: &mut ZFContext, data: &(Option<u128>,)) -> (bool, (InputRuleResult,)) {
        match data {
            (Some(_),) => (true, (InputRuleResult::Consume,)),
            (None,) => (false, (InputRuleResult::Wait,)),
        }
    }

    fn or_1(
        &mut self,
        _ctx: &mut ZFContext,
        data: (Option<String>, Option<u128>),
    ) -> (
        (Option<String>, Option<u128>),
        (Option<ZFCtrlMessage>, Option<ZFCtrlMessage>),
    ) {
        (data, (None, None))
    }
}

// Generated by Macro
impl FizzOperator {
    fn deserialize_input_0(data: &[u8]) -> u128 {
        zenoh_flow::bincode::deserialize::<u128>(data).unwrap()
    }

    fn serialize_output_0(data: String) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    fn serialize_output_1(data: u128) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    fn deserialize_state(data: &[u8]) -> FizzOperator {
        zenoh_flow::bincode::deserialize::<FizzOperator>(data).unwrap()
    }

    fn serialize_state(data: FizzOperator) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }
}

// Generated by Macro
impl zenoh_flow::ZFOperator for FizzOperator {
    fn make_run(&self, ctx: &mut zenoh_flow::ZFContext) -> Box<zenoh_flow::OperatorRun> {
        match ctx.mode {
            // mode id comes from the enum
            0 => {
                Box::new(
                    |ctx: &mut zenoh_flow::ZFContext,
                     data: Vec<Option<&zenoh_flow::message::Message>>|
                     -> zenoh_flow::OperatorResult {
                        // Zenoh Flow Ctrl IR - Inner
                        let inputs = (Some(FizzOperator::deserialize_input_0(
                            data[0].unwrap().data(),
                        )),);
                        let mut state = FizzOperator::deserialize_state(&ctx.state);

                        // User IR
                        match FizzOperator::ir_1(&state, ctx, &inputs) {
                            (false, (x,)) => {
                                // We should recover information in case of InputRuleResult::Drop, because we need to drop data
                                return zenoh_flow::OperatorResult::InResult(Ok((false, vec![x])));
                            }
                            _ => {
                                // User Run
                                let run_res = FizzOperator::run_1(&mut state, ctx, inputs);

                                //User OR
                                let (results, zf_results) =
                                    FizzOperator::or_1(&mut state, ctx, run_res);

                                // Zenoh Flow Ctrl OR - Inner
                                let outputs = vec![
                                    zenoh_flow::message::Message::new(
                                        FizzOperator::serialize_output_0(results.0.unwrap()),
                                    ),
                                    zenoh_flow::message::Message::new(
                                        FizzOperator::serialize_output_1(results.1.unwrap()),
                                    ),
                                ];

                                let zf_results = vec![zf_results.0, zf_results.1];
                                ctx.state = FizzOperator::serialize_state(state);
                                zenoh_flow::OperatorResult::OutResult(Ok((outputs, zf_results)))
                            }
                        }
                    },
                )
            }
            _ => panic!("Mode not found!"),
        }
    }
}
