// use dpn_macros::zfoperator;
use zenoh_flow::serde::{Deserialize, Serialize};
use zenoh_flow::InputRuleResult;
//use zenoh_flow_macros::ZFOperator;

use std::array::IntoIter;
use std::iter::FromIterator;

// #[zfoperator(
//     modes = {"default": {"ir" : 'ExampleOperator::ir_1, "run": ExampleOperator::run_1, "or" :ExampleOperator::or_1}},
//     inputs = [u128, String], // Can also pass a shared memory as input/output in that case we do not serialize/deserialize
//     output = [String, u128],
// )]
#[derive(Serialize, Deserialize)] //because of stateful, we need to serialize it inside the Runtime Context
struct ExampleOperator {
    // this is my state
    pub x: u128,
    pub y: String,
}
// Operator should have access to the context

// #[derive(ZFOperator)]
// #[inputs(u128, String)]
// struct ExampleOperator{}

impl ExampleOperator {
    fn run_1(&mut self, data: (Option<u128>, Option<String>)) -> (Option<String>, Option<u128>) {
        match data {
            (Some(u), Some(s)) => {
                self.x = u.clone();
                self.y = s.clone();
                (Some(s), Some(u))
            }
            (None, Some(s)) => (Some(s), None),
            (Some(u), None) => (None, Some(u)),
            (None, None) => (None, None),
        }
    }

    fn ir_1(
        &self,
        data: &(Option<u128>, Option<String>),
    ) -> (bool, (InputRuleResult, InputRuleResult)) {
        match data {
            (Some(_), Some(_)) => (true, (InputRuleResult::Process, InputRuleResult::Process)),
            (None, Some(_)) => (false, (InputRuleResult::Wait, InputRuleResult::Process)),
            (Some(_), None) => (false, (InputRuleResult::Process, InputRuleResult::Wait)),
            (None, None) => (false, (InputRuleResult::Wait, InputRuleResult::Wait)),
        }
    }

    fn or_1(&mut self, data: (Option<String>, Option<u128>)) -> (Option<String>, Option<u128>) {
        data
    }
}

// Generated by Macro
impl ExampleOperator {
    fn deserialize_input_0(data: &[u8]) -> u128 {
        zenoh_flow::bincode::deserialize::<u128>(data).unwrap()
    }

    fn deserialize_input_1(data: &[u8]) -> String {
        zenoh_flow::bincode::deserialize::<String>(data).unwrap()
    }

    fn serialize_output_0(data: String) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    fn serialize_output_1(data: u128) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    fn deserialize_state(data: &[u8]) -> ExampleOperator {
        zenoh_flow::bincode::deserialize::<ExampleOperator>(data).unwrap()
    }

    fn serialize_state(data: ExampleOperator) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    // KPN-like default Input Rule
    fn default_ir(
        &self,
        data: &(Option<u128>, Option<String>),
    ) -> (bool, (InputRuleResult, InputRuleResult)) {
        match data {
            (Some(_), Some(_)) => (true, (InputRuleResult::Process, InputRuleResult::Process)),
            (None, Some(_)) => (false, (InputRuleResult::Wait, InputRuleResult::Process)),
            (Some(_), None) => (false, (InputRuleResult::Process, InputRuleResult::Wait)),
            (None, None) => (false, (InputRuleResult::Wait, InputRuleResult::Wait)),
        }
    }

    // do-nothing default Output Rule
    fn default_or(
        &mut self,
        data: (Option<String>, Option<u128>),
    ) -> (Option<String>, Option<u128>) {
        data
    }
}

// Generated by Macro
impl zenoh_flow::ZFOperator for ExampleOperator {
    fn make_run(&self, ctx: &mut zenoh_flow::ZFContext) -> Box<zenoh_flow::OperatorRun> {
        match ctx.mode.as_str() {
            "default" => {
                Box::new(
                    |ctx: &mut zenoh_flow::ZFContext,
                     data: Vec<Option<&zenoh_flow::message::Message>>|
                     -> zenoh_flow::OperatorResult {
                        // Zenoh Flow Ctrl IR - Inner
                        let inputs = (
                            Some(ExampleOperator::deserialize_input_0(
                                data[0].unwrap().data(),
                            )),
                            Some(ExampleOperator::deserialize_input_1(
                                data[1].unwrap().data(),
                            )),
                        );
                        let mut state = ExampleOperator::deserialize_state(&ctx.state);
                        //

                        // User IR
                        match ExampleOperator::ir_1(&state, &inputs) {
                            (false, (x, y)) => {
                                // We should recover information in case of InputRuleResult::Drop, because we need to drop data
                                return zenoh_flow::OperatorResult::InResult(Ok((
                                    false,
                                    vec![x, y],
                                )));
                            }
                            _ => {
                                // User Run
                                let run_res = ExampleOperator::run_1(&mut state, inputs);

                                //User OR
                                let results = ExampleOperator::or_1(&mut state, run_res);

                                // Zenoh Flow Ctrl OR - Inner
                                let outputs = vec![
                                    zenoh_flow::message::Message::new(
                                        ExampleOperator::serialize_output_0(results.0.unwrap()),
                                    ),
                                    zenoh_flow::message::Message::new(
                                        ExampleOperator::serialize_output_1(results.1.unwrap()),
                                    ),
                                ];
                                ctx.state = ExampleOperator::serialize_state(state);
                                zenoh_flow::OperatorResult::OutResult(Ok((outputs, vec![])))
                                //
                            }
                        }
                    },
                )
            }
            _ => panic!("Mode not found!"),
        }
    }
}

fn main() {
    println!("hello");
}
