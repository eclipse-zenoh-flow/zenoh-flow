//
// Copyright (c) 2017, 2021 ADLINK Technology Inc.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ADLINK zenoh team, <zenoh@adlink-labs.tech>
//

#![allow(dead_code)]
#![allow(unused)]

// use dpn_macros::zfoperator;
use zenoh_flow::{
    message::ZFCtrlMessage,
    serde::{Deserialize, Serialize},
    ZFContext,
    types::{Token, NotReadyToken, ReadyToken},
};
//use zenoh_flow_macros::ZFOperator;

// #[zfoperator(
//     modes = {"default": {"ir" : 'ExampleOperator::ir_1, "run": ExampleOperator::run_1, "or" :ExampleOperator::or_1}},
//     inputs = [u128, String], // Can also pass a shared memory as input/output in that case we do not serialize/deserialize
//     output = [String, u128],
// )]
#[derive(Serialize, Deserialize)] //because of stateful, we need to serialize it inside the Runtime Context
struct ExampleOperator {
    // this is my state
    pub x: u128,
    pub y: String,
}
// Operator should have access to the context, maybe add a Weak<ZFContext>? -> https://users.rust-lang.org/t/solved-derive-and-proc-macro-add-field-to-an-existing-struct/52307/3

// #[derive(ZFOperator)]
// #[inputs(u128, String)]
// struct ExampleOperator{}

impl ExampleOperator {

    pub fn new() -> Self {
        Self {
            x : 0,
            y : "".to_string(),
        }
    }

    fn run_1(
        &mut self,
        _ctx: &mut ZFContext,
        data: (Option<u128>, Option<String>),
    ) -> (Option<String>, Option<u128>) {
        match data {
            (Some(u), Some(s)) => {
                self.x = u.clone();
                self.y = s.clone();
                (Some(s), Some(u))
            }
            (None, Some(s)) => (Some(s), None),
            (Some(u), None) => (None, Some(u)),
            (None, None) => (None, None),
        }
    }

    fn ir_1(
        &self,
        _ctx: &mut ZFContext,
        data: &mut (Token<u128>, Token<String>),
    ) -> bool {
        match data {
            (Token::Ready(_), Token::Ready(_)) => true,
            (Token::NotReady(_), Token::Ready(_)) => false,
            (Token::Ready(_), Token::NotReady(_)) => false,
            (Token::NotReady(_), Token::NotReady(_)) => false,
        }
    }

    fn or_1(
        &mut self,
        _ctx: &mut ZFContext,
        data: (Option<String>, Option<u128>),
    ) -> (
        (Option<String>, Option<u128>),
        (Option<ZFCtrlMessage>, Option<ZFCtrlMessage>),
    ) {
        (data, (None, None))
    }
}

// Generated by Macro
impl ExampleOperator {
    fn deserialize_input_0(data: &[u8]) -> u128 {
        zenoh_flow::bincode::deserialize::<u128>(data).unwrap()
    }

    fn deserialize_input_1(data: &[u8]) -> String {
        zenoh_flow::bincode::deserialize::<String>(data).unwrap()
    }

    fn serialize_output_0(data: String) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    fn serialize_output_1(data: u128) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    fn deserialize_state(data: &[u8]) -> ExampleOperator {
        zenoh_flow::bincode::deserialize::<ExampleOperator>(data).unwrap()
    }

    fn serialize_state(data: ExampleOperator) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    //KPN-like default Input Rule
    fn default_ir(
        &self,
        _ctx: &mut ZFContext,
        data: &mut (Token<u128>, Token<String>),
    ) -> bool {
        match data {
            (Token::Ready(_), Token::Ready(_)) => true,
            (Token::NotReady(_), Token::Ready(_)) => false,
            (Token::Ready(_), Token::NotReady(_)) => false,
            (Token::NotReady(_), Token::NotReady(_)) => false,
        }
    }

    //do-nothing default Output Rule
    fn default_or(
        &mut self,
        data: (Option<String>, Option<u128>),
    ) -> (
        (Option<String>, Option<u128>),
        (Option<ZFCtrlMessage>, Option<ZFCtrlMessage>),
    ) {
        (data, (None, None))
    }
}

// Generated by Macro
impl zenoh_flow::ZFOperator for ExampleOperator {
    fn make_run(&self, ctx: &mut zenoh_flow::ZFContext) -> Box<zenoh_flow::OperatorRun> {
        match ctx.mode {
            // mode id comes from the enum
            0 => {
                Box::new(
                    |ctx: &mut zenoh_flow::ZFContext,
                     data: Vec<&zenoh_flow::message::ZFMessage>|
                     -> zenoh_flow::OperatorResult {
                        // Zenoh Flow Ctrl IR - Inner
                        let mut inputs = (
                            zenoh_flow::types::Token::<u128>::new_ready(0u128, ExampleOperator::deserialize_input_0(
                                data[0].data(),
                            )),
                            zenoh_flow::types::Token::<String>::new_ready(0u128, ExampleOperator::deserialize_input_1(
                                data[1].data(),
                            )),
                        );
                        let mut state = ExampleOperator::deserialize_state(&ctx.state);

                        // User IR
                        match ExampleOperator::ir_1(&state, ctx, &mut inputs) {
                            false => {
                                // We should recover information in case of InputRuleResult::Drop, because we need to drop data
                                return zenoh_flow::OperatorResult::InResult(Ok((
                                    false,
                                    vec![inputs.0.split().1, inputs.1.split().1],
                                )));
                            }
                            _ => {

                                let run_inputs = (
                                    inputs.0.split().0,
                                    inputs.1.split().0,
                                );

                                // User Run
                                let run_res = ExampleOperator::run_1(&mut state, ctx, run_inputs);

                                //User OR
                                let (results, zf_results) =
                                    ExampleOperator::or_1(&mut state, ctx, run_res);

                                // Zenoh Flow Ctrl OR - Inner
                                let outputs = vec![
                                    zenoh_flow::message::Message::new(
                                        ExampleOperator::serialize_output_0(results.0.unwrap()),
                                    ),
                                    zenoh_flow::message::Message::new(
                                        ExampleOperator::serialize_output_1(results.1.unwrap()),
                                    ),
                                ];

                                let zf_results = vec![zf_results.0, zf_results.1];
                                ctx.state = ExampleOperator::serialize_state(state);
                                zenoh_flow::OperatorResult::OutResult(Ok((outputs, zf_results)))
                            }
                        }
                    },
                )
            }
            _ => panic!("Mode not found!"),
        }
    }
}

//Also generated by macro
zenoh_flow::export_operator!(register);

extern "C" fn register(registrar: &mut dyn zenoh_flow::loader::ZFOperatorRegistrarTrait) {
    registrar.register_zfoperator(
        "print",
        Box::new(ExampleOperator::new()) as Box<dyn zenoh_flow::ZFOperator + Send>,
    );
}
