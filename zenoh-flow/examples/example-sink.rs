//
// Copyright (c) 2017, 2021 ADLINK Technology Inc.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ADLINK zenoh team, <zenoh@adlink-labs.tech>
//

use zenoh_flow::{
    message::Message,
    serde::{Deserialize, Serialize},
    ZFContext,
};

// #[zfoperator(
//     modes = {"default": {"ir" : 'ExampleSink::ir_1, "run": ExampleSink::run_1, "or" :ExampleSink::or_1}},
//     inputs = [u128, String], // Can also pass a shared memory as input/output in that case we do not serialize/deserialize
//     output = [String, u128],
// )]

// Because of stateful, we need to serialize it inside the Runtime Context.
#[derive(Serialize, Deserialize)]
struct ExampleSink {}
// Operator should have access to the context, maybe add a Weak<ZFContext>? -> https://users.rust-lang.org/t/solved-derive-and-proc-macro-add-field-to-an-existing-struct/52307/3

// #[derive(ZFOperator)]
// #[inputs(u128, String)]
// struct ExampleSink{}

impl ExampleSink {
    fn run_1(&mut self, _ctx: &mut ZFContext, data: (Option<String>,)) {
        println!("Received: {}", data.0.unwrap())
    }
}

// Generated by Macro
impl ExampleSink {
    fn deserialize_input_0(data: &[u8]) -> String {
        zenoh_flow::bincode::deserialize::<String>(&data).unwrap()
    }

    fn deserialize_state(data: &[u8]) -> ExampleSink {
        zenoh_flow::bincode::deserialize::<ExampleSink>(data).unwrap()
    }
}

// Generated by Macro
impl zenoh_flow::ZFSink for ExampleSink {
    fn make_sink(&self, ctx: &mut zenoh_flow::ZFContext) -> Box<zenoh_flow::ZFSinkRun> {
        match ctx.mode {
            // mode id comes from the enum
            0 => {
                Box::new(
                    |ctx: &mut zenoh_flow::ZFContext,
                     data: Vec<Option<&Message>>|
                     -> zenoh_flow::ZFSinkResult {
                        let inputs = (Some(ExampleSink::deserialize_input_0(
                            data[0].unwrap().data(),
                        )),);
                        // Zenoh Flow Ctrl IR - Inner
                        let mut state = ExampleSink::deserialize_state(&ctx.state);

                        // User Run
                        Ok(ExampleSink::run_1(&mut state, ctx, inputs))
                    },
                )
            }
            _ => panic!("Mode not found!"),
        }
    }
}
