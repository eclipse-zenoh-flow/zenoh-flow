//
// Copyright (c) 2017, 2021 ADLINK Technology Inc.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ADLINK zenoh team, <zenoh@adlink-labs.tech>
//

use std::io;

use zenoh_flow::{
    serde::{Deserialize, Serialize},
    ZFContext,
};

// #[zfoperator(
//     modes = {"default": {"ir" : 'ExampleSource::ir_1, "run": ExampleSource::run_1, "or" :ExampleSource::or_1}},
//     inputs = [u128, String], // Can also pass a shared memory as input/output in that case we do not serialize/deserialize
//     output = [String, u128],
// )]

// Because of stateful, we need to serialize it inside the Runtime Context.
#[derive(Serialize, Deserialize)]
struct ExampleSource {}
// Operator should have access to the context, maybe add a Weak<ZFContext>? -> https://users.rust-lang.org/t/solved-derive-and-proc-macro-add-field-to-an-existing-struct/52307/3

// #[derive(ZFOperator)]
// #[inputs(u128, String)]
// struct ExampleSource{}

impl ExampleSource {
    fn run_1(&mut self, _ctx: &mut ZFContext) -> (Option<u128>,) {
        let mut value_str = String::new();
        print!("\n Please insert an integer: ");
        io::stdin()
            .read_line(&mut value_str)
            .expect("Failed to read line");

        (Some(u128::from_str_radix(&value_str, 10).unwrap()),)
    }
}

// Generated by Macro
impl ExampleSource {
    fn serialize_output_0(data: u128) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }

    fn deserialize_state(data: &[u8]) -> ExampleSource {
        zenoh_flow::bincode::deserialize::<ExampleSource>(data).unwrap()
    }

    fn serialize_state(data: ExampleSource) -> Vec<u8> {
        zenoh_flow::bincode::serialize(&data).unwrap()
    }
}

// Generated by Macro
impl zenoh_flow::ZFSource for ExampleSource {
    fn make_source(&self, ctx: &mut zenoh_flow::ZFContext) -> Box<zenoh_flow::ZFSourceRun> {
        match ctx.mode {
            // mode id comes from the enum
            0 => {
                Box::new(
                    |ctx: &mut zenoh_flow::ZFContext| -> zenoh_flow::ZFSourceResult {
                        // Zenoh Flow Ctrl IR - Inner
                        let mut state = ExampleSource::deserialize_state(&ctx.state);

                        // User Run
                        let run_res = ExampleSource::run_1(&mut state, ctx);

                        // Zenoh Flow Ctrl OR - Inner
                        let outputs = vec![zenoh_flow::message::Message::new(
                            ExampleSource::serialize_output_0(run_res.0.unwrap()),
                        )];
                        ctx.state = ExampleSource::serialize_state(state);

                        Ok(outputs)
                    },
                )
            }
            _ => panic!("Mode not found!"),
        }
    }
}
