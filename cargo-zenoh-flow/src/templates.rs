//
// Copyright (c) 2022 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//

use crate::{CZFError, CZFResult};
use serde::Serialize;
use tinytemplate::TinyTemplate;

static CARGO_OPERATOR_TEMPLATE: &str = r#"
zenoh-flow = \{ git = "https://github.com/eclipse-zenoh/zenoh-flow.git", branch = "master"}

[lib]
name = "{name}"
crate-type=["cdylib"]
path="src/lib.rs"

[package.metadata.zenohflow]
id = "{name}"
kind = "operator"
inputs=[ \{id ="INPUT", type="bytes"}]
outputs=[ \{id ="OUTPUT", type="bytes"}]

"#;

static CARGO_SOURCE_TEMPLATE: &str = r#"
zenoh-flow = \{ git = "https://github.com/eclipse-zenoh/zenoh-flow.git", branch = "master"}
async-trait = "0.1"

[lib]
name = "{name}"
crate-type=["cdylib"]
path="src/lib.rs"

[package.metadata.zenohflow]
id = "{name}"
kind = "source"
outputs=[ \{id ="Data", type="bytes"}]

"#;

static CARGO_SINK_TEMPLATE: &str = r#"
zenoh-flow = \{ git = "https://github.com/eclipse-zenoh/zenoh-flow.git", branch = "master"}
async-trait = "0.1"

[lib]
name = "{name}"
crate-type=["cdylib"]
path="src/lib.rs"

[package.metadata.zenohflow]
id = "{name}"
kind = "sink"
inputs=[ \{id ="Data", type="bytes"}]

"#;

static LIB_OPERATOR_TEMPLATE: &str = r#"
use std::sync::Arc;
use std::collections::HashMap;
use zenoh_flow::zenoh_flow_derive::ZFState;
use zenoh_flow::\{
    default_input_rule, default_output_rule, Node, NodeOutput, Data, Operator,
    ZFResult, ZFState, PortId, Configuration, State, LocalDeadlineMiss
};

#[derive(Debug)]
struct {name};

static INPUT: &str = "INPUT";
static OUTPUT: &str = "OUTPUT";

impl Operator for {name} \{

    fn input_rule(
        &self,
        _context: &mut zenoh_flow::Context,
        state: &mut State,
        tokens: &mut HashMap<PortId, zenoh_flow::InputToken>,
    ) -> ZFResult<bool> \{
        default_input_rule(state, tokens)
    }

    fn run(
        &self,
        _context: &mut zenoh_flow::Context,
        state: &mut State,
        inputs: &mut HashMap<PortId, zenoh_flow::runtime::message::DataMessage>,
    ) -> ZFResult<HashMap<PortId, Data>> \{
        todo!()
    }

    fn output_rule(
        &self,
        _context: &mut zenoh_flow::Context,
        state: &mut State,
        outputs: HashMap<PortId, Data>,
        _deadlinemiss: Option<LocalDeadlineMiss>,
    ) -> ZFResult<HashMap<PortId, NodeOutput>> \{
        default_output_rule(state, outputs)
    }
}

impl Node for {name} \{
    fn initialize(
        &self,
        _configuration: &Option<Configuration>,
    ) -> ZFResult<State>  \{
        zenoh_flow::zf_empty_state!()
    }

    fn finalize(&self, _state: &mut State) -> ZFResult<()> \{
        Ok(())
    }
}

// Also generated by macro
zenoh_flow::export_operator!(register);

fn register() -> ZFResult<Arc<dyn Operator>> \{
    Ok(Arc::new({name}) as Arc<dyn Operator>)
}

"#;

static LIB_SOURCE_TEMPLATE: &str = r#"
use std::sync::Arc;
use async_trait::async_trait;
use std::collections::HashMap;
use zenoh_flow::zenoh_flow_derive::ZFState;
use zenoh_flow::\{Node, Data, Source,
    ZFResult, ZFState, PortId, Configuration, State
};

#[derive(Debug)]
struct {name};

#[async_trait]
impl Source for {name} \{
    async fn run(
        &self,
        _context: &mut zenoh_flow::Context,
        state: &mut State,
    ) -> ZFResult<Data> \{
        todo!()
    }

}


impl Node for {name} \{
    fn initialize(
        &self,
        _configuration: &Option<Configuration>,
    ) -> ZFResult<State>  \{
        zenoh_flow::zf_empty_state!()
    }

    fn finalize(&self, _state: &mut State) -> ZFResult<()> \{
        Ok(())
    }
}

// Also generated by macro
zenoh_flow::export_source!(register);

fn register() -> ZFResult<Arc<dyn Source>> \{
    Ok(Arc::new({name}) as Arc<dyn Source>)
}

"#;

static LIB_SINK_TEMPLATE: &str = r#"
use std::sync::Arc;
use async_trait::async_trait;
use std::collections::HashMap;
use zenoh_flow::zenoh_flow_derive::ZFState;
use zenoh_flow::\{Node, Data, Sink,
    ZFResult, ZFState, PortId, Configuration, State
};

#[derive(Debug)]
struct {name};

#[async_trait]
impl Sink for {name} \{
    async fn run(
        &self,
        _context: &mut zenoh_flow::Context,
        state: &mut State,
        mut input: zenoh_flow::runtime::message::DataMessage,
    ) -> ZFResult<()> \{
        todo!()
    }
}


impl Node for {name} \{
    fn initialize(
        &self,
        _configuration: &Option<Configuration>,
    ) -> ZFResult<State>  \{
        zenoh_flow::zf_empty_state!()
    }

    fn finalize(&self, _state: &mut State) -> ZFResult<()> \{
        Ok(())
    }
}

// Also generated by macro
zenoh_flow::export_sink!(register);

fn register() -> ZFResult<Arc<dyn Sink>> \{
    Ok(Arc::new({name}) as Arc<dyn Sink>)
}

"#;

static PY_SINK_TEMPLATE: &str = r#"
from zenoh_flow.interfaces import Sink
from zenoh_flow.types import Context, DataMessage
from typing import Any

class {name}(Sink):
    def initialize(self, configuration = dict) -> Any:
        raise NotImplementedError("Please implement your own method")

    def finalize(self, state: Any) -> None:
        raise NotImplementedError("Please implement your own method")

    def run(self, ctx : Context, state: Any, input: DataMessage) -> None:
        raise NotImplementedError("Please implement your own method")


def register():
    return {name}

"#;

static PY_SRC_TEMPATE: &str = r#"
from zenoh_flow.interface import Source
from zenoh_flow.types import Context
from typing import Any

class {name}(Source):

    def initialize(self, configuration: dict) -> Any:
        raise NotImplementedError("Please implement your own method")

    def finalize(self, state: Any) -> None:
        raise NotImplementedError("Please implement your own method")

    def run(self, context: Context, state: Any) -> bytes:
        raise NotImplementedError("Please implement your own method")



def register():
    return {name}
"#;

static PY_OP_TEMPLATE: &str = r#"
from zenoh_flow.interfaces import Operator
from zenoh_flow.types import Context, InputToken, LocalDeadlineMiss, DataMessage
from typing import Dict, Optional, Any

class {name}(Operator):

    def input_rule(self, context: Context, state : Any, tokens: Dict[str, InputToken]) -> bool:
        raise NotImplementedError("Please implement your own method")

    def output_rule(self, context: Context, state : Any, outputs : Dict[str, bytes] , deadline_miss: Optional[LocalDeadlineMiss] = None) -> Dict[str, bytes]:
        raise NotImplementedError("Please implement your own method")

    def run(self, context: Context, state : Any, inputs: Dict[str, DataMessage]) -> Dict[str, bytes]:
        raise NotImplementedError("Please implement your own method")

    def initialize(self, configuration: dict) -> Any:
        raise NotImplementedError("Please implement your own method")

    def finalize(self, state : Any) -> None:
        raise NotImplementedError("Please implement your own method")


def register():
    return {name}
"#;

#[derive(Serialize)]
struct OperatorContext {
    name: String,
}

fn some_kind_of_uppercase_first_letter(s: &str) -> String {
    let s = str::replace(s, "-", "_");
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
    }
}

pub fn operator_template_cargo(name: String) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("operator", CARGO_OPERATOR_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(&name),
    };

    tt.render("operator", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}

pub fn operator_template_lib(name: String) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("operator", LIB_OPERATOR_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(&name),
    };

    tt.render("operator", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}

pub fn source_template_lib(name: String) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("source", LIB_SOURCE_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(&name),
    };

    tt.render("source", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}

pub fn source_template_cargo(name: String) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("source", CARGO_SOURCE_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(&name),
    };

    tt.render("source", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}

pub fn sink_template_lib(name: String) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("sink", LIB_SINK_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(&name),
    };

    tt.render("sink", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}

pub fn sink_template_cargo(name: String) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("sink", CARGO_SINK_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(&name),
    };

    tt.render("sink", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}

pub fn source_template_py(name: &str) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("source", PY_SRC_TEMPATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(name),
    };

    tt.render("source", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}

pub fn operator_template_py(name: &str) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("source", PY_OP_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(name),
    };

    tt.render("source", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}

pub fn sink_template_py(name: &str) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("source", PY_SINK_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(name),
    };

    tt.render("source", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}
